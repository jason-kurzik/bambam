#!/usr/bin/env python3
# Copyright (C)
#    2007-2008 Don Brown,
#    2010 Spike Burch <spikeb@gmail.com>,
#    2015-2016 Vasya Novikov
#    2018 Olivier Mehani <shtrom+bambam@ssji.net>
#    2018-2020 Marcin Owsiany <marcin@owsiany.pl>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import print_function
import gettext
import pygame
import sys
import os
import random
import argparse
import fnmatch
from pygame.locals import Color, QUIT, KEYDOWN, MOUSEMOTION, MOUSEBUTTONDOWN, MOUSEBUTTONUP


# noinspection PyPep8Naming
def N_(s): return s


# TRANSLATORS: command string to mute sounds.
# Must not contain spaces, and should be be at least 4 characters long,
# so that it is unlikely to be generated by a keyboard-mashing baby.
MUTE_STRING = N_('mute')
# TRANSLATORS: command string to unmute sounds.
# Must not contain spaces, and should be be at least 4 characters long,
# so that it is unlikely to be generated by a keyboard-mashing baby.
UNMUTE_STRING = N_('unmute')
# TRANSLATORS: command string to quit the game.
# Must not contain spaces, and should be be at least 4 characters long,
# so that it is unlikely to be generated by a keyboard-mashing baby.
QUIT_STRING = N_('quit')


class BambamException(Exception):
    """Represents a bambam-specific exception."""
    pass


class ResourceLoadException(BambamException):
    """Represents a failure to load a resource."""

    def __init__(self, resource, message):
        self._resource = resource
        self._message = message

    def __str__(self):
        return _('Failed to load file "%(file)s": %(message)s') % dict(file=self._resource, message=self._message)


def init_joysticks():
    """
    Initializes all joysticks available on the system and assigns them unique
    identifiers for further use.

    """
    pygame.joystick.init()
    """
    Initialize all joysticks.
    """
    joystick_count = pygame.joystick.get_count()
    for i in range(joystick_count):
        joystick = pygame.joystick.Joystick(i)
        joystick.init()


class Bambam:
    IMAGE_MAX_WIDTH = 700

    @classmethod
    def get_color(cls):
        """
        Calculates and returns a color value based on a specified hue value,
        saturation, and value, all between 0 and 100.

        Args:
            cls (int): 360-degree hue angle of the generated color.

        Returns:
            pygame.Color: a white color with an hsva value of (hue, 100, 100, 100).
            
            		- `hue`: The angle of the color in degrees, ranging from 0 to 360.
            		- `sat`: The brightness of the color, set to 100.
            		- `val`: The value of the color, set to 100.
            		- `alpha`: The transparency of the color, set to 100.

        """
        hue = pygame.time.get_ticks() / 50 % 360
        color = Color('white')
        color.hsva = (hue, 100, 100, 100)
        return color

    @classmethod
    def load_image(cls, fullname):
        """
        Loads an image from a file, resizes it to fit within a maximum width and
        height, and returns the scaled image.

        Args:
            cls (object/instance of `ResourceClass` class.): class where the
                function is defined and provides access to the member variables
                of that class.
                
                		- `IMAGE_MAX_WIDTH`: This is an attribute of `cls` that represents
                the maximum width allowed for the image after resizing. It is
                specified as a plain value without any units.
                		- `IMAGE_MAX_HEIGHT`: This is another attribute of `cls` that
                represents the maximum height allowed for the image after resizing.
                It is specified as a plain value without any units.
            fullname (str): name of the image file to be loaded.

        Returns:
            pygame.Surface: a scaled down version of the input image that fits
            within the specified dimensions.
            
            		- `image`: A pygame image object containing the loaded image.
            		- `size_x`, `size_y`: The dimensions of the loaded image in pixels.
            		- `new_size_x`, `new_size_y`: The resized dimensions of the image
            if it was too large to fit within the specified maximum size.
            		- `raise ResourceLoadException`: An exception raised if the image
            could not be loaded or resized due to errors.

        """
        try:
            image = pygame.image.load(fullname)

            size_x, size_y = image.get_rect().size
            if size_x > cls.IMAGE_MAX_WIDTH or size_y > cls.IMAGE_MAX_WIDTH:
                new_size_x = cls.IMAGE_MAX_WIDTH
                new_size_y = int(cls.IMAGE_MAX_WIDTH * (float(size_y)/size_x))
                if new_size_y < 1:
                    raise ResourceLoadException(
                        fullname,
                        _("image has height of 0 after resizing to fit within %(width)dx%(height)d pixels") % dict(
                            width=cls.IMAGE_MAX_WIDTH, height=cls.IMAGE_MAX_WIDTH))

                image = pygame.transform.scale(image, (new_size_x, new_size_y))

        except pygame.error as message:
            raise ResourceLoadException(fullname, message)

        return image.convert()

    @classmethod
    def load_sound(cls, name):
        """
        Loads a sound from a given name and returns it as an instance of
        `pygame.mixer.Sound`. If the sound cannot be loaded, a `ResourceLoadException`
        is raised with the name of the sound and the error message.

        Args:
            cls ("ResourceLoadException" type object.): class `NoneSound` in this
                function.
                
                		- The `play` method is a non-callable method that simply does nothing.
                		- The `NoneSound` instance is returned if no error occurs during
                initialization or sound loading.
                		- If there's an error loading the sound, the `ResourceLoadException`
                is raised with the sound name and error message as arguments.
            name (str): name of the sound to be played.

        Returns:
            None: a `ResourceLoadException` object if the sound file cannot be loaded.

        """
        class NoneSound:
            def play(self): pass
        if not pygame.mixer or not pygame.mixer.get_init():
            return NoneSound()
        try:
            return pygame.mixer.Sound(name)
        except pygame.error as message:
            raise ResourceLoadException(name, message)

    @classmethod
    def load_items(cls, lst, blacklist, load_function, failure_message):
        """
        Takes a list of file paths as input, applies blacklist filtering, and then
        tries to load each remaining item using a provided load function. If all
        items pass loading, the function returns the loaded results, otherwise it
        raises an exception.

        Args:
            cls ('Exception'.): Bambam exception class, which is used to raise an
                exception with a custom message if any errors occurred during the
                load process.
                
                		- `lst`: A list of strings representing item paths.
                		- `blacklist`: A list of wildcard patterns used to skip blacklisted
                items.
                		- `result`: A list of loaded items (can be `None`).
                		- `errors_encountered`: A boolean indicating if any loading
                errors occurred.
                		- `failure_message`: A message describing the error if
                `errors_encountered` is True.
            lst (list): list of file paths to be scanned for loading into the
                `result` variable.
            blacklist (list): list of image or sound file paths that should be
                excluded from being processed by the `load_function()` method.
            load_function (exception object.): image or sound file path that is
                to be loaded into the function.
                
                	1/ `load_function`: This is the function that is loaded from disk.
                Its properties or attributes are not explicitly mentioned in the
                given code snippet. However, it could potentially have a return
                value, parameters, and/or other attributes based on its implementation.
            failure_message (str): message to be displayed if any loading errors
                occur during the execution of the function.

        Returns:
            list: a list of loaded items or an error message if any blacklisted
            items were encountered.

        """
        result = []
        errors_encountered = False
        for name in lst:
            if any(fnmatch.fnmatch(name, p) for p in blacklist):
                # TRANSLATORS: "item" can refer to an image or sound file path
                print(_("Skipping blacklisted item %s") % name)
            else:
                try:
                    result.append(load_function(name))
                except ResourceLoadException as e:
                    print(e)
                    errors_encountered = True
        if not result and errors_encountered:
            raise BambamException(failure_message)
        return result

    def __init__(self):
        """
        Sets initial values for attributes including `colors`, `data_dirs`, `args`,
        `images`, `sounds`, and configures displays and audio settings.

        """
        self.colors = ((0, 0, 255), (255, 0, 0), (255, 255, 0),
                       (255, 0, 128), (0, 0, 128), (0, 255, 0),
                       (255, 128, 0), (255, 0, 255), (0, 255, 255)
                       )
        self.data_dirs = []
        self.args = None

        self.images = None
        self.sounds = None

        self.background = None
        self.screen = None
        self.display_height = None
        self.display_width = None

        self.sequence = ""
        self.sound_muted = None

    def draw_dot(self):
        """
        1) retrieves the current mouse position using Pygame's `mouse.get_pos()`
        function, then 2) creates a white circle with a radius equal to the
        difference between the mouse position and the circle center (using Pygame's
        `Surface` class and `draw.circle()` method), and finally 3) sets the color
        key of the circle to 0 using `set_colorkey()` method to make it invisible
        when the screen is drawn, and blits the circle at the correct position
        using `blit()` method.

        """
        r = 30
        mouse_x, mouse_y = pygame.mouse.get_pos()

        dot = pygame.Surface((2 * r, 2 * r))
        pygame.draw.circle(dot, self.get_color(), (r, r), r, 0)
        dot.set_colorkey(0, pygame.RLEACCEL)

        self.screen.blit(dot, (mouse_x - r, mouse_y - r))

    def process_keypress(self, event):
        """
        Processes keyboard input, checking for command words and performing actions
        based on their presence in the sequence. It also randomizes sound playback
        and displays images based on the key press.

        Args:
            event (`pygame.Event` object.): Python event object passed from the
                event loop and provides information about the current keyboard or
                mouse event, such as the type of event, the key code, and any
                additional metadata.
                
                		- `type`: The type of event that occurred (either `KEYDOWN` or
                `QUIT`).
                		- `unicode`: The Unicode value of the key pressed (if `type ==
                KEYDOWN`).
                		- `key`: The key code of the pressed key (if `type == KEYDOWN).
                
                	The `event.unicode` property is a string that contains the Unicode
                value of the key pressed, while `event.key` is an integer that
                represents the key code of the pressed key.

        """
        # check for command words
        if event.type == KEYDOWN and event.unicode.isalpha():
            self.sequence += event.unicode
            if self.sequence.find(_(QUIT_STRING)) > -1:
                sys.exit(0)
            elif self.sequence.find(_(UNMUTE_STRING)) > -1:
                self.sound_muted = False
                # pygame.mixer.unpause()
                self.sequence = ''
            elif self.sequence.find(_(MUTE_STRING)) > -1:
                self.sound_muted = True
                pygame.mixer.fadeout(1000)
                self.sequence = ''

        # Clear the screen 10% of the time
        if random.randint(0, 10) == 1:
            self.screen.blit(self.background, (0, 0))
            pygame.display.flip()

        # play random sound
        if not self.sound_muted:
            if event.type == KEYDOWN and self.args.deterministic_sounds:
                self.sounds[event.key % len(self.sounds)].play()
            else:
                self.sounds[random.randint(
                    0, len(self.sounds) - 1)].play()

        # show self.images
        if event.type == pygame.KEYDOWN and (event.unicode.isalpha() or event.unicode.isdigit()):
            self.print_letter(event.unicode)
        else:
            self.print_image()
        pygame.display.flip()

    def print_image(self):
        """
        Generates a random image from an array of images and displays it on the
        screen at a random location within its bounds.

        """
        img = self.images[random.randint(0, len(self.images) - 1)]
        w = random.randint(0, self.display_width - img.get_width())
        h = random.randint(0, self.display_height - img.get_height())
        self.screen.blit(img, (w, h))

    def print_letter(self, char):
        """
        Render a single letter on the screen using Pygame font and center it
        horizontally and vertically within the display boundaries.

        Args:
            char (str): 1-pixel wide image to be displayed as a random character.

        """
        font = pygame.font.Font(None, 256)
        if self.args.uppercase:
            char = char.upper()
        text = font.render(
            char, 1, self.colors[random.randint(0, len(self.colors) - 1)])
        text_pos = text.get_rect()
        center = (text_pos.width // 2, text_pos.height // 2)
        w = random.randint(0 + center[0], self.display_width - center[0])
        h = random.randint(0 + center[1], self.display_height - center[1])
        text_pos.centerx = w
        text_pos.centery = h
        self.screen.blit(text, text_pos)

    def glob_dir(self, path, extensions):
        """
        Iterates over the files and directories within a given path, extending a
        list of file paths based on their extensions.

        Args:
            path (os. Path): directory or folder where the search for files will
                be conducted.
                
                		- `os.listdir(path)`: Returns a list of filenames in the directory
                `path`.
                		- `os.path.join(path, file_name)`: Constructs a new path by
                joining two paths. The first argument is the directory `path`, and
                the second argument is the filename `file_name`.
                		- `if os.path.isdir(path_name):`: Checks if the path `path_name`
                exists and is a directory.
                		- `files.extend(self.glob_dir(path_name, extensions))`: Appends
                the files found in the subdirectory `path_name` to the list of
                files `files`, using the `glob_dir` function.
                		- `else:`: Executed if the previous `if` statement is false.
                		- `for ext in extensions:`: Iterates over a list of file extensions
                `extensions`.
                		- `if path_name.lower().endswith(ext):`: Checks if the filename
                `path_name` ends with the specified extension `ext`, ignoring case.
                		- `files.append(path_name)`: Adds the matching files to the list
                `files`.
                		- `break`: Exits the inner loop.
            extensions (list): list of file extensions that should be considered
                for the directory or file search.

        Returns:
            list: a list of file paths that match the specified extension(s).

        """
        files = []
        for file_name in os.listdir(path):
            path_name = os.path.join(path, file_name)
            if os.path.isdir(path_name):
                files.extend(self.glob_dir(path_name, extensions))
            else:
                for ext in extensions:
                    if path_name.lower().endswith(ext):
                        files.append(path_name)
                        break

        return files

    def glob_data(self, extensions):
        """
        Iterates over a list of directory paths (`data_dirs`) and for each path
        it recursively enumerates all files within that directory and its
        subdirectories using the `glob` module, and then adds those files to a
        list called `file_list`.

        Args:
            extensions (list): lowercase version of the file extensions that the
                `glob_dir()` method should search for within each data directory
                specified in the `data_dirs` variable.

        Returns:
            list: a list of files in the specified data directories with file names
            matching the provided extensions.

        """
        extensions = [x.lower() for x in extensions]
        file_list = []
        for data_dir in self.data_dirs:
            file_list.extend(self.glob_dir(data_dir, extensions))
        return file_list

    def _prepare_background(self):
        # noinspection PyArgumentList
        """
        Creates a black background Surface for the main game loop using `pygame.Surface`,
        and sets the background color to either dark or light based on the `args`.
        It also creates a font object for displaying command messages at the top
        of the screen using `pygame.font.SysFont`, renders the message with the
        specified font and color, and blits it to the upper right corner of the
        background Surface.

        """
        self.background = pygame.Surface(self.screen.get_size()).convert()
        self.background_color = (0, 0, 0) if self.args.dark else (250, 250, 250)
        self.background.fill(self.background_color)
        caption_font = pygame.font.SysFont(None, 20)
        caption_label = caption_font.render(
            # TRANSLATORS: the string is space-separated list of all command strings.
            _("Commands: %s") % " ".join(_(s) for s in [QUIT_STRING, MUTE_STRING, UNMUTE_STRING]),
            True,
            (210, 210, 210),
            self.background_color)
        caption_rect = caption_label.get_rect()
        caption_rect.x = 15
        caption_rect.y = 10
        self.background.blit(caption_label, caption_rect)

    def _prepare_wayland_warning(self):
        """
        Displays a message on top of the game window with the warning text when
        Wayland is detected as the display server.

        """
        caption_font = pygame.font.SysFont(None, 80)
        for i, msg in enumerate([
                _("Error: Wayland display detected."),
                _("Cannot lock the keyboard safely."),
                "",
                _("Press any key to quit.")]):
            caption_label = caption_font.render(
                msg,
                True,
                (250, 0, 0),
                self.background_color)
            caption_rect = caption_label.get_rect()
            caption_rect.x = 150
            caption_rect.y = 100 + (i * 80)
            self.background.blit(caption_label, caption_rect)

    def run(self):
        """
        Initializes the Python Pygame library, sets up a window and caption, loads
        sounds and images, and defines event handling for keypresses, mouse motion,
        and button presses/releases.

        """
        program_base = os.path.dirname(os.path.realpath(sys.argv[0]))

        dist_data_dir = os.path.join(program_base, 'data')
        if os.path.isdir(dist_data_dir):
            print(_('Using data directory %s') % dist_data_dir)
            self.data_dirs.append(dist_data_dir)
        installed_data_dir = os.path.join(os.path.dirname(program_base), 'share')
        xdg_data_home = os.getenv('XDG_DATA_HOME', os.path.expanduser('~/.local/share'))
        for bambam_base_dir in [installed_data_dir, xdg_data_home]:
            extra_data_dir = os.path.join(bambam_base_dir, 'bambam', 'data')
            if os.path.isdir(extra_data_dir):
                print(_('Using data directory %s') % extra_data_dir)
                self.data_dirs.append(extra_data_dir)

        parser = argparse.ArgumentParser(
            description=_('A keyboard mashing game for babies.'))
        parser.add_argument('-u', '--uppercase', action='store_true',
                            help=_('Show UPPER-CASE letters.'))
        parser.add_argument('--sound_blacklist', action='append', default=[],
                            help=_('List of sound filename patterns to never play.'))
        parser.add_argument('--image_blacklist', action='append', default=[],
                            help=_('List of image filename patterns to never show.'))
        parser.add_argument('-d', '--deterministic-sounds', action='store_true',
                            help=_('Produce same sounds on same key presses.'))
        parser.add_argument('-D', '--dark', action='store_true',
                            help=_('Use a dark background instead of a light one.'))
        parser.add_argument('-m', '--mute', action='store_true',
                            help=_('Do not play any sounds.'))
        parser.add_argument('--wayland-ok', action='store_true',
                            help=_('Do not prevent running under Wayland.'))
        self.args = parser.parse_args()

        pygame.init()

        if not pygame.font:
            print(_('Warning, fonts disabled.'))
        if not pygame.mixer or not pygame.mixer.get_init():
            print(_('Warning, sound disabled.'))

        pygame.display.set_mode((0, 0), pygame.FULLSCREEN)

        # determine display resolution
        display_info = pygame.display.Info()
        self.display_width = display_info.current_w
        self.display_height = display_info.current_h

        # TRANSLATORS: Main game window name.
        pygame.display.set_caption(_('Bam Bam'))
        self.screen = pygame.display.get_surface()

        self._prepare_background()
        clock = pygame.time.Clock()

        if not self.args.wayland_ok and (os.getenv('WAYLAND_DISPLAY') or os.getenv('XDG_SESSION_TYPE') == 'wayland'):
            in_wayland = True
            self._prepare_wayland_warning()
        else:
            in_wayland = False

        self.screen.blit(self.background, (0, 0))
        pygame.display.flip()

        while in_wayland:
            clock.tick(60)
            for event in pygame.event.get():
                if event.type in [QUIT, KEYDOWN, pygame.JOYBUTTONDOWN, MOUSEBUTTONDOWN]:
                    sys.exit(1)

        self.sound_muted = self.args.mute

        self.sounds = self.load_items(
            self.glob_data(['.wav', '.ogg']),
            self.args.sound_blacklist,
            self.load_sound,
            _("All sounds failed to load."))

        self.images = self.load_items(
            self.glob_data(['.gif', '.jpg', '.jpeg', '.png', '.tif', '.tiff']),
            self.args.image_blacklist,
            self.load_image,
            _("All images failed to load."))

        init_joysticks()

        mouse_pressed = False
        while True:
            clock.tick(60)
            for event in pygame.event.get():
                if event.type == QUIT:
                    sys.exit(0)

                elif event.type == KEYDOWN or event.type == pygame.JOYBUTTONDOWN:
                    self.process_keypress(event)

                # mouse motion
                elif event.type == MOUSEMOTION:
                    if mouse_pressed:
                        self.draw_dot()
                        pygame.display.flip()

                # mouse button down
                elif event.type == MOUSEBUTTONDOWN:
                    self.draw_dot()
                    mouse_pressed = True
                    pygame.display.flip()

                # mouse button up
                elif event.type == MOUSEBUTTONUP:
                    mouse_pressed = False


def main():
    """
    Attempts to initiate a `Bambam` instance and run it, but if any BambamException
    is thrown, it will print the exception message and exit the program with an
    error code of 1.

    """
    gettext.install('bambam')
    try:
        bambam = Bambam()
        bambam.run()
    except BambamException as e:
        print(e)
        sys.exit(1)


if __name__ == '__main__':
    main()
